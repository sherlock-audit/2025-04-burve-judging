Great Iris Zebra

Medium

# Absence of Protocol Fees for Vault Yield

### Summary
In the current implementation, the protocol does not collect fees from the yield generated by `VaultE4626`. 
It is unclear whether this is an intentional design choice, as there is no documentation addressing this aspect.

### Root Cause
https://github.com/sherlock-audit/2025-04-burve/tree/main/Burve/src/multi/vertex/Vertex.sol#L60
```solidity
    function trimBalance(
        Vertex storage self,
        ClosureId cid,
        uint256 targetReal,
        uint256 value,
        uint256 bgtValue
    ) internal returns (uint256 reserveSharesEarned, uint256 bgtResidual) {
        VaultProxy memory vProxy = VaultLib.getProxy(self.vid);
        uint256 realBalance = vProxy.balance(cid, false);
        // We don't error and instead emit in this scenario because clearly the vault is not working properly but if
        // we error users can't withdraw funds. Instead the right response is to lock and move vaults immediately.
        if (targetReal > realBalance) {
            emit InsufficientBalance(self.vid, cid, targetReal, realBalance);
            return (0, 0);
        }
        uint256 residualReal = realBalance - targetReal;
        vProxy.withdraw(cid, residualReal);
        bgtResidual = FullMath.mulDiv(residualReal, bgtValue, value);
        reserveSharesEarned = ReserveLib.deposit(
            vProxy,
            self.vid,
            residualReal - bgtResidual
        );
        vProxy.commit();
    }
```

### Internal pre-conditions
N/A

### External pre-conditions
N/A

### Attack Path
N/A

### PoC
https://github.com/sherlock-audit/2025-04-burve/tree/main/Burve/test/facets/ValueFacet.t.sol
```solidity
    function test_protocolfee() public {
        uint256 oneX128 = 1 << 128;
        vm.prank(owner);
        simplexFacet.setClosureFees(0x7, uint128(oneX128 / 1000), uint128(oneX128 / 10));

        valueFacet.addValue(alice, 0x7, 3e20, 0);
        
        MockERC20(tokens[1]).mint(address(vaults[1]), 3e18); // add yield into vault1

        uint256[4] memory alice_initBalances = getBalances(alice);
        vm.startPrank(alice);
        valueFacet.collectEarnings(alice, 0x7);
        uint256[4] memory alice_currentBalances = getBalances(alice);
        int256[4] memory alice_diffs = diffBalances(alice_currentBalances, alice_initBalances);

        console.log("user's earnings[1]    : %e", alice_diffs[1]);

        uint256[4] memory initBalances = getBalances(owner);
        vm.startPrank(owner);
        simplexFacet.withdraw(tokens[1]);
        uint256[4] memory currentBalances = getBalances(owner);
        int256[4] memory diffs = diffBalances(currentBalances, initBalances);
        console.log("earned protocol fees  : %e\n", diffs[1]);
    }
```
Result:
```bash
Ran 1 test for test/facets/ValueFacet.t.sol:ValueFacetTest
[PASS] test_protocolfee() (gas: 1101007)
Logs:
  user's earnings[1]    : 4.99999997500000011e17
  earned protocol fees  : 0e0
```

### Impact
The protocol does not collect fees from the yield generated by the vault.

### Mitigation
Consider implementing protocol fees in the `Closure::_trimBalance` function.
